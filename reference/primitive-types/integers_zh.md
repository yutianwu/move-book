---
title: '整数 | 参考'
description: ''
---

# 整数

Move支持六种无符号整数类型：`u8`、`u16`、`u32`、`u64`、`u128`和`u256`。这些类型的值范围从0到取决于类型大小的最大值。

| 类型                             | 值范围              |
| -------------------------------- | ------------------------ |
| 无符号8位整数，`u8`     | 0 到 2<sup>8</sup> - 1   |
| 无符号16位整数，`u16`   | 0 到 2<sup>16</sup> - 1  |
| 无符号32位整数，`u32`   | 0 到 2<sup>32</sup> - 1  |
| 无符号64位整数，`u64`   | 0 到 2<sup>64</sup> - 1  |
| 无符号128位整数，`u128` | 0 到 2<sup>128</sup> - 1 |
| 无符号256位整数，`u256` | 0 到 2<sup>256</sup> - 1 |

## 字面量

这些类型的字面量值指定为数字序列（例如，`112`）或十六进制字面量，例如`0xFF`。类型可以可选地作为后缀添加，例如`112u8`。如果没有指定类型，编译器将尝试从使用字面量的上下文推断类型。如果无法推断类型，则假定为`u64`。

数字字面量可以用下划线分隔以进行分组和可读性（例如，`1_234_5678`、`1_000u128`、`0xAB_CD_12_35`）。

如果字面量对于其指定（或推断）的大小范围太大，则报告错误。

### 示例

```move
// 带显式注解的字面量；
let explicit_u8 = 1u8;
let explicit_u16 = 1u16;
let explicit_u32 = 1u32;
let explicit_u64 = 2u64;
let explicit_u128 = 3u128;
let explicit_u256 = 1u256;
let explicit_u64_underscored = 154_322_973u64;

// 简单推断的字面量
let simple_u8: u8 = 1;
let simple_u16: u16 = 1;
let simple_u32: u32 = 1;
let simple_u64: u64 = 2;
let simple_u128: u128 = 3;
let simple_u256: u256 = 1;

// 复杂推断的字面量
let complex_u8 = 1; // 推断：u8
// 移位的右侧参数必须是u8
let _unused = 10 << complex_u8;

let x: u8 = 38;
let complex_u8 = 2; // 推断：u8
// `+`的参数必须具有相同类型
let _unused = x + complex_u8;

let complex_u128 = 133_876; // 推断：u128
// 从函数参数类型推断
function_that_takes_u128(complex_u128);

// 字面量可以用十六进制写
let hex_u8: u8 = 0x1;
let hex_u16: u16 = 0x1BAE;
let hex_u32: u32 = 0xDEAD80;
let hex_u64: u64 = 0xCAFE;
let hex_u128: u128 = 0xDEADBEEF;
let hex_u256: u256 = 0x1123_456A_BCDE_F;
```

## 操作

### 算术运算

每种类型都支持相同的检查算术操作集。对于所有这些操作，两个参数（左侧和右侧操作数）_必须_是相同类型。如果您需要对不同类型的值进行操作，首先需要执行[转换](#casting)。类似地，如果您期望操作的结果对于整数类型太大，在执行操作之前执行到更大大小的[转换](#casting)。

所有算术操作都会中止，而不是以数学整数不会的方式行为（例如，溢出、下溢、除零）。

| 语法 | 操作           | 中止条件                                |
| ------ | ------------------- | ---------------------------------------- |
| `+`    | 加法            | 结果对于整数类型太大 |
| `-`    | 减法         | 结果小于零                 |
| `*`    | 乘法      | 结果对于整数类型太大 |
| `%`    | 模除法    | 除数为`0`                       |
| `/`    | 截断除法 | 除数为`0`                       |

### 位运算

整数类型支持以下位运算，将每个数字视为一系列单独的位（0或1），而不是数值整数值。

位运算不会中止。

| 语法              | 操作   | 描述                                           |
| ------------------- | ----------- | ----------------------------------------------------- |
| `&`                 | 位与 | 对每个位对执行布尔与          |
| <code>&#124;</code> | 位或  | 对每个位对执行布尔或           |
| `^`                 | 位异或 | 对每个位对执行布尔异或 |

### 位移

类似于位运算，每种整数类型都支持位移。但与其他操作不同，右侧操作数（要移位的位数）必须_始终_是`u8`，不需要与左侧操作数（您要移位的数字）匹配。

如果要移位的位数大于或等于`u8`、`u16`、`u32`、`u64`、`u128`或`u256`分别对应的`8`、`16`、`32`、`64`、`128`或`256`，位移可能会中止。

| 语法 | 操作   | 中止条件                                                               |
| ------ | ----------- | ----------------------------------------------------------------------- |
| `<<`   | 左移  | 要移位的位数大于整数类型的大小 |
| `>>`   | 右移 | 要移位的位数大于整数类型的大小 |

### 比较

整数类型是Move中_唯一_可以使用比较操作符的类型。两个参数需要是相同类型。如果您需要比较不同类型的整数，必须首先[转换](#casting)其中一个。

比较操作不会中止。

| 语法 | 操作                |
| ------ | ------------------------ |
| `<`    | 小于                |
| `>`    | 大于             |
| `<=`   | 小于或等于    |
| `>=`   | 大于或等于 |

### 相等性

像所有具有[`drop`](./../abilities_zh)的类型一样，所有整数类型都支持["相等"](./../equality_zh)和["不相等"](./../equality_zh)操作。两个参数需要是相同类型。如果您需要比较不同类型的整数，必须首先[转换](#casting)其中一个。

相等操作不会中止。

| 语法 | 操作 |
| ------ | --------- |
| `==`   | 相等     |
| `!=`   | 不相等 |

有关更多详细信息，请参阅[相等性](./../equality_zh)部分。

## 转换

一种大小的整数类型可以转换为另一种大小的整数类型。整数是Move中唯一支持转换的类型。

转换_不会_截断。如果结果对于指定类型太大，转换会中止。

| 语法     | 操作                                            | 中止条件                              |
| ---------- | ---------------------------------------------------- | -------------------------------------- |
| `(e as T)` | 将整数表达式`e`转换为整数类型`T` | `e`太大无法表示为`T` |

这里，`e`的类型必须是`8`、`16`、`32`、`64`、`128`或`256`，`T`必须是`u8`、`u16`、`u32`、`u64`、`u128`或`u256`。

例如：

- `(x as u8)`
- `(y as u16)`
- `(873u16 as u32)`
- `(2u8 as u64)`
- `(1 + 3 as u128)`
- `(4/2 + 12345 as u256)`

## 所有权

与语言内置的其他标量值一样，整数值是隐式可复制的，这意味着它们可以在没有显式指令（如[`copy`](./../variables_zh#move-and-copy)）的情况下被复制。